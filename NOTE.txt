=> dotenv is a Node.js module that loads environment variables from a .env file into process.env

Dev dependencies are those which are done during development and not taken into production

Middleswares-> 
It has codes that are needed to be ran in-between.
That is if I want to send request to server and in between that request if I want to put some check-in functionality then at that time Middleswares comes into business

Utlis folder contain utility files used for specific functions like file upload, tokens sharing etc.


While using Database use trycatch and async await

since we are importing dotenv which is an experimental process, so we are using dotenv as an expermental feature in package.json
"scripts": {
    "dev": "nodemon -r dotenv/config --experimental-json-modules src/index.js"
  },

=> app.use() is used when we want to set some middleware or configuration

=> ` bcrypt ` helps us to hash passwords i.e solves the problem of encryption, dycryption


=>=>=>=> CODE breakdown- for [app.use] in src/app.js

const app = express();: This line creates an instance of the Express application. The express() function is a top-level function exported by the Express.js framework that creates a new Express application.

app.use(express.json({ limit: "16kb" }));: This line adds middleware to parse incoming requests with JSON payloads. It uses express.json() middleware provided by Express to parse the request body when it contains JSON data. The { limit: "16kb" } option specifies the maximum size of the JSON payload that the server will accept, limiting it to 16 kilobytes.

app.use(express.urlencoded({ extended: true, limit: "16kb" }));: This line adds middleware to parse incoming requests with URL-encoded payloads. It uses express.urlencoded() middleware to parse data submitted through HTML forms. The options { extended: true, limit: "16kb" } specify that the URL-encoded data can contain rich objects (extended: true) and also sets a limit of 16 kilobytes for the payload.

app.use(express.static("public"));: This line serves static files from the "public" directory. The express.static() middleware is used to serve static files such as images, stylesheets, and JavaScript files. In this case, it is configured to serve files from the "public" directory.

app.use(cookieParser());: This line adds middleware to parse cookies from the incoming requests. The cookieParser() middleware parses cookies attached to the client's request and makes them available in the req.cookies object. This allows the server to easily work with cookies sent by the client.

In summary, these lines of code set up an Express.js application with middleware for handling JSON and URL-encoded data in requests, serving static files from a "public" directory, and parsing cookies from incoming requests.


=> httpOnly: When set to true, this property indicates that the cookie should be accessible only through the HTTP protocol. This helps to mitigate certain types of security risks, such as cross-site scripting (XSS), by preventing client-side scripts from accessing the cookie.

=> secure: When set to true, this property indicates that the cookie should only be sent over secure, encrypted connections (HTTPS). This is an additional security measure to ensure that sensitive information in the cookie is transmitted securely.


=> jwt.verify(token, process.env.ACCESS_TOKEN_SECRET) 

The code is checking whether the provided JWT (token) is valid by verifying its signature using the secret key (process.env.ACCESS_TOKEN_SECRET). If the signature is valid, it means the JWT has not been tampered with and can be trusted. If the verification is successful, the function typically returns the decoded content of the JWT, allowing the program to access the information stored within it. If the verification fails, it may throw an error or return a false value, depending on the implementation


=> About upload.single("avatar") -> middleware
When you use upload.single("avatar"):

Multer looks for a file attached to the request under the field name "avatar."
It processes the file according to the configured storage engine (in your case, it will use the disk storage defined earlier).
It then attaches the information about the uploaded file to the req object, specifically to req.file.
If you omit upload.single("avatar"):

Express won't automatically process the file upload.
The req.file object won't be populated with information about the uploaded file.
In your updateUserAvatar function, you won't have access to the uploaded file's details, making it challenging to handle the avatar update logic correctly.